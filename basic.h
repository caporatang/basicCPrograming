//
// Created by capor on 2023-09-18.
//

#ifndef SCHOOL_BASIC_H
#define SCHOOL_BASIC_H

#include <iostream>

using namespace std;
// keyword : C++ 언어에서 미리 용도를 정해 놓은 단어, 반드시 정해진 용도로만 사용해야 함
// 식별자 : 여러 가지 대상을 구분하기 위해 만든 이름 (변수나 함수, 클래스 등의 이름)
// 식별자를 만드는 규칙
// 1. 첫 자는 비 숫자 문자를 사용함
// 2. 이후의 문자는 비 숫자 문자와 숫자를 사용함
// 3. 길이 제한은 없음
// 4. 키워드는 식별자로 사용할 수 없음

class basic {
    // 기본 자료형 : 기본적으로 제공되는 하나의 값을 저장할 수 있는 자료형
    // 복합 자료형 : 배열, 구조체(struct), 클래스(class), 열거형(enum), 공용체(union), 포인터, 참조

    // 정수 자료형(integral types)
    // 고정소수점(fixed-point) 방식의 숫자 표현 : 오버플로가 발생하지 않도록 주의해야 함
    // 문자를 표현하는 자료형 : char
    // 정수를 표현하는 자료형 : int, short, long, long long
    // 두 자료형은 signed 또는 unsigned

    // 참/거짓을 표현하는 자료형
    // bool : true, false

    // 다국어 표현을 위한 자료형 : wchar_t, char16_t, char32_t

    // 실수 자료형 : float : 4byte , double : 8byte

    // 상수의 표현 - 리터럴(literal)
    // 정수형 리터럴의 표현 : 숫자를 표현하는 문자와 부호만으로 표현됨 -> '0' ~ '9' 까지의 숫자 , 10~15에 해당되는 16진수를 표현하기 위한 문자 'a'~'f'와 'A'~'F'
    // 접두사를 이용한 진법의 표현 :
    // 1. 159 : 10진수 int형 상수
    // 2. 0b10011111 : 2진수 int형 상수 : 0b 로 시작
    // 3. 0237 : 8진수 int형 상수 : 0으로 시작
    // 4. 0x9f : 16진수 int형 상수 : 0x로 시작

    // 접미사를 이요한 정수 리터럴의 자료형
    // 123 : int 형
    // 123u : unsigned int형
    // 123L : long 형
    // 123ul : unsigned long 형
    // 123ll : long long 형

    // 문자 리터럴의 표현 : 작은 따옴표(' ') 안에 문자를 표기하는 방법
    // 8진수나 16진수 문자 코드로 표기하는 방법
    // 문자 'A' (ASCII 코드에 해당되는 정수 65와 동일)
    // '\101' 'A'와 동일함 (65의 8진수 표현)
    // '\x41' 'A'와 동일함 (65의 16진수 표현)

    // 실수형 리터럴의 표현 : 소수점이 있거나 10의 거듭제곱을 표현하기 위한 지수 기호인 'e'가 있으면 실수형 리터럴임
    // 1200. , 1200.0 , 12e2 , 1.2e+3  -> double형 값 1200
    // 1200.0f , 12e2f -> float형 값 1200
};

int main() {
    // 변수란? 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역, 변수에는 자료형과 이름이 지정되어야 함, 모든 변수는 사용하기 전에 미리 선언해야 함
    int korScore, mathScore;
    cin >> korScore >> mathScore;
    float avrScore = (korScore + mathScore) / 2.0f;

    // 변수의 초기화
    int total=0;
    int total2(0);
    int total3{0};

    // 자료형 추론 : 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론함
    auto i(10); // <- int로 자동 추론

};
// 변수의 사용 영역(scope) : 변수가 유효성을 갖는 영역
                    // 비 지역변수
int a;              // 선언된 이후 프로그램의 전체 영역에서 사용 가능
static int b{10};   // 소속 파일의 전체 영역 사용 가능
int f() {
    int c{20}, d{30};  // 선언되 이후 소속 블록에서 사용 가능
    {
                    // 지역 변수
        int d{40}; // 선언된 이후 소속 블록의 전체 영역 사용 가능
        int e{50};
    }
}

extern int a;       // 외부 파일에 있는 변수를 사용하는 extern 키워드

// const 한정어 : 변수의 값을 수정할 수 없게 함, 초기화를 통해서만 값을 정할 수 있음
const double PI {3.14159};

// constexpr 한정어 : 그 값을 컴파일할 때 평가한다는 의미, 실행 중 값을 평가하는 것에 비해 효율적으로 동작할 수 있게 함
int q() {
    int a;
    std::cin >> a;
    const int b = 20;
    const int C1 = a;               // cin을 통해 입력된 a의 값으로 초기화
    // constexpr int C2 = a + 10;  // 오류 : 컴파일 시에 a의 값을 알 수 없음
    constexpr int C3 = b + 100;
    // constexpr int C4 = C1 * 2;  // 오류 : 컴파일 시에 C1의 값을 알 수 없음
}

 constexpr int fac(int n) {
    // cconstexpr 함수 : 모둔 인수가 constexpr인 경우 컴파일할 때 값을 구할 수 있게 함
    return n > 1 ? n * fac(n-1) : 1;
}
void f(int x) {
    constexpr int a= fac(4); //컴파일 할 때 계산
    int b = fac(x);          // 실행 중 계산
}

// 변수의 유효기간(lifetime) 이란 ? 변수가 언제 만들어져서 언제 없어지는가를 나타냄
// 자동 변수
// 생성 시점 : 함수(블록)가 시작될 때
// 소멸 시점 : 함수(블록)가 종료될 때

// 정적 변수
// 생성 시점 : 프로그램이 시작될 때
// 소멸 시점 : 프로그램이 종료될 때

int x;               // 전역변수 - 정적 유효기간
int o() {
    int y{10};       // 지역 변수 - 자동 유효기간
    static int z{0}; // 정적 지역변수 - 정적 유효기간
}

// 산술 연산자
// 2항 연산자 : 사칙 연산자 : + - * /    나머지 연산자 : %
// 단항 연산자 : 증, 감 연산자 : ++, --
// a가 10일 때
// b = ++a; :  a : 11 , b: 11
// b = a++; : a 11 , b 10
// b = --a; : a 9 , b 9
// b = a--; : a 9, b 10

// 부호 연산자 : +, -
// 대입 연산자(=) 수식의 값 : 저장된 결과, 연산자의 결합 방향 : 우 -> 좌
// a = 0; -> a 0
// a = b = 0; -> a = 0, b = 0
// a = b = 1.5; a = 1 , b = 1 (a double , b int)

// 복합 대입 연산자 : 이항 연산자와 대입 연산자를 결합
// 관계 연산자 : <, >, >=, <=, ==, !=

// 비트 단위 논리 연산자 : 논리 합 | , 논리곱 &, 배타적 논리 합 ^, 부정 ~
// x는 0x35 (0011 0101)
// y는 0xf0(1111 0000) 이라고 가정
// x | y -> 0xf5 (1111 0101)
// x & y -> 0x30 (0011 0000)
// x ^ y -> 0xc5 (1100 0101)
// ~x -> 0xca (1100 1010)

// 비트 이동 연산자 : 좌측 이동(<<) : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 좌측으로 이동 -> 우측의 비는 비트에는 0이 채워진다
unsigned char x2 = 0b00011101; // 29
unsigned char y2 = x << 2;
// x : 0 0 0 1 1 1 0 1
// y : 0 1 1 1 0 1 0 0 -> 116

// 우측 이동 (>>) : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 우측으로 이동
// singed형에 대해서는 부호를 유지할 수 있도록 부호 비트가 좌측의 비는 비트에 채움
char x3 = 0b10010100; // -108
char y = x >>2 ; //-> -27


// 묵시적 형 변환
// 두 값 사이의 연산에서는 우선 순위가 낮은 자료형의 값이 순위가 높은 자료형의 값과 같은 형으로 변환된다.
// 여러 개의 연산으로 구성된 수식에서 묵시적 형 변환은 연산자 단위로 이루어짐
// 대입 연산자는 값을 저장할 변수의 자료형으로 묵시적 형변환을 함
// int intVar;
// double doubleVar;
// float floatVar;
// intVar = doubleVar + intVar * floatVar;

// 명시적 형 변환
// static_cast : 연관된 자료형 간의 형 변환을 처리, 변환 처리는 컴파일 단계에서 정해진다.
// dynamic_cast : 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 지시힘
// reinterpret_cast : 관련이 없는 자료형 사이의 변환을 처리하는 연산자로, 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환함
// const_cast : const 지정을 일시 해제함

#endif //SCHOOL_BASIC_H
